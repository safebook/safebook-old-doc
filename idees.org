#+TITLE: Idées
#+HTML_HEAD: <link href="solarized-light.min.css" rel="stylesheet"></link>
#+OPTIONS: toc:nil num:nil

* Cryptographie
  
** Techniques

*** Chiffrement

    Un message peut ou non être chiffré par l'utilisateur.
    
    Permet de se passer d'un tiers pour controller l'accès à l'information.

    Un chiffrement cryptographique garanti que seul les possesseurs de la clé de déchiffrement pouront le lire.


*** Authentification

    Un message peut ou non être signé par l'utilisateur.

    Permet de se passer d'un tiers pour garantir l'authentification des données.

    Une signature cryptographique prouve que ce message a bien été envoyé par l'utilisateur.
    
    
*** Fonction de hachage cryptographie

    Une fonction de hachage cryptographie donne l'*empreinte cryptographique* d'un message.
    
    L'empreinte cryptographique est suffisament longue et cryptique pour avoir ces deux propriétés :

    Aucun autre message calculable n'a la même empreinte cryptographique.
    
    Il n'est pas possible de retrouver le message seulement à partir de son empreinte.


*** Clés de chiffrement et de déchiffrement
    
    Une *clé cryptographique* est un moyen de chiffrer (crypter) ou de déchiffrer des données.
    
    Une clé de chiffrement *symétrique* permet de chiffrer et dechiffrer des données.

    Ses possesseurs forment donc le groupe ayant le pouvoir de lire les messages chiffrés.
    

*** Clés de chiffrement uniquement

    Une *clé de déchiffrement asymétrique* permet de génerer la *clé de chiffrement asymétrique* correspondante.

    Une *clé de chiffrement asymétrique* permet de chiffrer des messages mais pas de les déchiffrer.

    Ses possesseurs peuvent donc uniquement chiffrer des messages, sans pouvoir les relire.

    Seul le (ou les) possesseur(s) de la *clé de déchiffrement* correspondante a(ont) le pouvoir de les lire.

    
*** Clés d'authentification et de vérification

    Une *clé de signature cryptographique* de permet d'authentifier un message.
    
    Elle permet aussi de générer la *clé de verification cryptographique* correspondante.
    
    La *clé de vérification* peut être partagée afin de rendre possible la vérifaction des messages signés.


*** Arbre cryptographique

    Un *arbre cryptographique* utilise une *graine cryptographique* pour générer
    un ensemble de branches et feuilles qui peuvent toutes être utilisés comme *clés cryptographiques*
    
    [[https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki][Hierarchical Deterministic Wallets]] (BIP-32)


** Concepts
   
*** Trustless
    
    Nous ne devrions pas avoir besoin de faire confiance au serveur
    pour ne pas lire et analyser nos message.
    
    Il devrait donc être impossible à un tiers de lire, ou modifier
    notre flux de communication. Pour cela nous utiliseront la cryptographie.

    Les données chiffrés devraient pouvoir être ouvertes à tous
    sans que cela puisse nous compromettre.


*** Types de messages
   
   Chaque utilisateur ayant des besoins spécifiques

   Nous aurons différent types de messages, par exemple :

   - En clair: contenu public

   - Zero: pas de métadata (exemples: bitmessage, minilock)

   - Direct: Message to public key (M2PK)

   - Satoshi: Message to public key hash (M2PKH)


*** Types de messages (2)

   - Un message *en clair* est publiquement lisible.

   - Un message avec *zero information* est complétement illisible avant d'être dechiffré.
     Aucune information n'est disponible pour savoir quelle clé peut le déchiffrer.

   - Un message avec *adresse publique* identifie *la clé de déchiffrement asymétrique* permettant de le déchiffrer.

   - Un message avec *empreinte d'adresse publique* identifie l'*empreinte* de la *clé de déchiffrement asymétrique* permettant de le déchiffrer.

   - Un message avec *signature cryptographique* est authentifiable par la *clé de vérification*


*** Types d'adresses

   Chaque utilisateur ayant des besoins spécifiques

   Nous aurons donc différent types d'adresses, ainsi que
   différent types d'encodage.
   
   Types d'adresses :

   - Clé publique
   - Empreinte de clé publique (ex: SFGAftzSTztFSB8LMwsrdCKTyqGY6zr3sU).
     Est plus court qu'une clé publique, et ne la divulgue pas.
   - Pseudo grace avec un système de 'DNS'

   Types d'encodages :
   
   - Binary
   - Base58
   - Suite de mots (ex: give input convince decide dizzy tag flash spawn)
   - QR Code

   
*** Comptes (arbres)
    
    Nous utiliserons une graine cryptographie comme un arbre infini
    générant un flux infini et infiniment dichotomisable d'adresses et de clés.
    
    Certaines clés serviront à destocker (en dechiffrant) certaines
    informations chiffrés.

    Certaines clés sont telles quelles des adresse bitcoin, litecoin, etc...
    
    En partageant une graine cryptographique avec un ami,
    il est possible de dériver l'arbre chacun de son coté
    et de s'en servir comme clés de chiffrement ou comme points
    de rendez vous sans autres négociations.



*** Pseudo/Email/Identifiant

    C'est un outil permettant à la platforme de reconnaitre ses utilisateurs.
    
    Nous n'avons pas besoin que l'utilisateur en choisisse un car il est déjà
    uniquement identifiable par son adresse cryptographique.

    Il est seulement intéressant pour l'utilisateur de choisir sous quel nom il apparait par défaut


*** Mot de passe

    C'est un outil permettant à la platforme de reconnaitre ses utilisateurs.

    Nous préférons une signature cryptographie ou un mot de passe à usage unique
    pour ne pas embarasser l'utilisateur d'avoir à se souvenir d'un mot de passe
    different pour chaque platforme qu'il utilise.

* Interfaces
   
   Nous ne voulons pas limiter le logiciel à une seule interface.
   
   Cependant pour simplifier le developpement
   il est pratique de proposer une interface standart.

   Pour répondre au besoin de chacun,
   chaque utilisateur devrai avoir la possibilité de
   personnaliser son interface. Autant comment il apparait aux autres
   que comment les autres lui apparaissent.

   Les conversations, groupes et événements devraient être
   modifiable à deux échelles, globalement et localement (pour chacun).


* Vrac

*** Introduction

Avec l'arrivée d'internet, la société n'a cessé de se copier-coller dans ce nouvel espace.

Cette nouvelle surface d'échange autorise l'émergence et la contemplation de nouvelles structures.

Une structure particulièrement vivace - le sujet de cette reflexion - c'est le réseau social.

Il est assujetti à un nouvel ensemble de règles, comme les platformes et les interfaces.

Son potentiel : Aider à recoder l'information pour décoder le réél.


*** Ne pas s'intéresser au transfert ni au stockage des données

    Il est utile étude de ne s'interesser ni aux mechanismes
    de distribution des messages, ni au stockage des messages.

    Nous nous limitons donc à regarger l'échange
    pair-à-pair (peer-to-peer) et de bout-en-bout (end-to-end)
    comme si il était toujours possible.


*** Données immutables

    Oublier le cas où on peut effacer ou modifier.

    Nous pourrons ainsi créer plus facilement des hiérarchies de structure.


*** Optimistic CRDT

    using resource id and modification time


*** Gaussian filter to query the server

    Do not ask the server full addresses
    use a filter or just the start of the string
    and ask fake addresses on top of it


*** Programmed message

    Message we only want to send at a fixed time


*** Systemes

**** Systeme 0

    Tous les messages n'inscrive séquentiellement dans une bande de stockage infini
    {m0..|m1.......|m2|m3..|m4......|m5..|.....}
    Un message ne contient aucune métadata
    Tout le monde recoit les messages de tout le monde
    Personne ne sait qui parle à qui


**** Systeme 1

    message n:
    { destination: user n | content: data }
    ou
    { source: user n | content: data }
    ou (plus souvent)
    { source: user n | destination: user m | content: data }
    Un user peut être représenté par n'importe quoi.
    Rien n'est dit sur la possibilité ou non d'impersonnifer quelqu'un (usurpation d'identité). A priori c'est possible.


**** Systeme 2

    message n:
    { (source) | (destination) | previous: message m | content }
    ou
    { (source) | (destination) | thread_id: data | content }
    Pour simplifier on pourrait garder que le deuxième cas en utilisant si besoin le hash du message précédent comme thread_id
    Les parenthèses signinfie que c'est optionel (soit présent soit absent), soit par système, soit par message dans un système plus global


*** Technologies Utiles

   - Cryptographie (hashs, chiffrement symétrique et asymétrique, signatures)
   - Pair-à-pair
   - CRDTs
   - Graphes
   - IPFS
   - Données sémantiques
